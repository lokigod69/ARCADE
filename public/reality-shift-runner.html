<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Shift Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #fff;
        }
        .container {
            position: relative;
            border: 2px solid #fff;
        }
        canvas {
            display: block;
            background: #111;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            text-shadow: 0 0 5px #0ff;
        }
        #intro, #victoryScreen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #noflow, #victoryScreen {
            display: none;
        }
        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            box-shadow: 0 0 15px #0ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="c" width="800" height="600"></canvas>
        <div id="ui">Time: <span id="t">0.0</span></div>
        <div id="intro">
            <h1 style="color:#0ff; text-shadow:0 0 12px #f0f;">Reality Shift Runner</h1>
            <div id="noflow">Your browser does not support this game.</div>
            <div id="msg" style="font-size: 18px; margin: 10px 0;"></div>
            <button id="play">Begin</button>
        </div>
        <div id="victoryScreen">
            <h1 style="color:#0ff; text-shadow:0 0 12px #f0f;">UNIVERSE ALIGNED!</h1>
            <p>You bent reality to your will.</p>
            <button onclick="RealityShiftRunner.reset()">Play Again</button>
        </div>
    </div>
    <script>
(function (global) {
    // =========================================================================
    // FEATURE PROBE & EARLY EXIT
    // =========================================================================
    const hasDOM = typeof window !== "undefined" && typeof document !== "undefined";
    const canvas = hasDOM && document.getElementById("c");
    const ctx = canvas && canvas.getContext && canvas.getContext("2d");
    if (!hasDOM || !ctx) {
        if (hasDOM) {
            document.getElementById("noflow").style.display = "block";
            document.getElementById("play").style.display = "none";
        }
        return void(global.RealityShiftRunner = { init: () => console.log("No DOM/Canvas available.") });
    }
    // =========================================================================
    // CONFIGURATION & CONSTANTS
    // =========================================================================
    const CONFIG = {
        TIMING: { STEP: 1 / 60 },
        PHYSICS: {
            playerAccel: 9,
            gravity: 48,
            friction: 0.98,
            jumpImpulse: 312,
        },
        COLORS: ["#00fff0", "#ff00ff", "#ffff00", "#ffffff"], // neon palette for realm hints
        GRAVITY_DIRS: [[0, 1], [1, 0], [0, -1], [-1, 0]],
    };
    
    // =========================================================================
    // LEVEL DATA
    // =========================================================================
    const LEVELS = [
        {
            time: 30,
            playerStart: { x: 60, y: 480 },
            exit: { x: 720, y: 120, size: 24 },
            platforms: [
                { x: 50, y: 520, w: 700, h: 20, d: 0 }, { x: 100, y: 380, w: 140, h: 20, d: 2 },
                { x: 300, y: 300, w: 200, h: 20, d: 1 }, { x: 600, y: 200, w: 140, h: 20, d: 3 }
            ]
        },
        {
            time: 45,
            playerStart: { x: 60, y: 560 },
            exit: { x: 400, y: 60, size: 24 },
            platforms: [
                { x: 20, y: 580, w: 760, h: 20, d: 0 }, { x: 780, y: 20, w: 20, h: 560, d: 1 },
                { x: 20, y: 0, w: 760, h: 20, d: 2 }, { x: 0, y: 20, w: 20, h: 560, d: 3 },
                { x: 200, y: 400, w: 20, h: 180, d: 1 }, { x: 400, y: 200, w: 200, h: 20, d: 2 },
                { x: 600, y: 200, w: 20, h: 200, d: 3 }, { x: 100, y: 100, w: 200, h: 20, d: 0 }
            ]
        }
    ];
    // =========================================================================
    // GAME STATE & UI MANAGERS
    // =========================================================================
    const GameState = { START: 'START', PLAYING: 'PLAYING', PAUSED: 'PAUSED', END: 'END' };
    
    class UIManager {
        constructor() {
            this.timeEl = document.getElementById("t");
            this.introEl = document.getElementById("intro");
            this.msgEl = document.getElementById("msg");
            this.playBtn = document.getElementById("play");
            this.victoryScreen = document.getElementById("victoryScreen");
        }
        update(game) { this.timeEl.textContent = game.timer.toFixed(1); }
        showIntro(msg = "") {
            this.introEl.style.display = "flex"; this.msgEl.textContent = msg;
            this.victoryScreen.style.display = 'none';
        }
        hideIntro() { this.introEl.style.display = "none"; }
        showVictory() { this.victoryScreen.style.display = "flex"; this.hideIntro(); }
    }

    class InputManager {
        constructor() {
            this.keys = {}; this.canJump = true;
            addEventListener("keydown", e => this.handleKey(e, true));
            addEventListener("keyup", e => this.handleKey(e, false));
        }
        handleKey(e, isDown) {
            if (e.key === "Escape" && isDown) { game.togglePause(); }
            const keyMap = { ArrowLeft: 'left', a: 'left', ArrowRight: 'right', d: 'right', ArrowUp: 'jump', ' ': 'jump', z: 'jump' };
            const action = keyMap[e.key];
            if (action) {
                if (action === 'jump') {
                    if (isDown && this.canJump) { this.keys.jump = true; this.canJump = false; }
                    if (!isDown) this.canJump = true;
                } else { this.keys[action] = isDown; }
            }
        }
    }
    // =========================================================================
    // ENTITY DEFINITIONS
    // =========================================================================
    class Entity {
        constructor({ x, y, w, h }) { Object.assign(this, { x, y, w, h, vx: 0, vy: 0 }); }
        get center() { return { x: this.x + (this.w || this.size) / 2, y: this.y + (this.h || this.size) / 2 }; }
    }

    class Player extends Entity {
        constructor(config) { super(config); this.onGround = false; }
    }
    class Platform extends Entity {
        constructor(config) { super(config); this.d = config.d; }
    }
    class Exit extends Entity {
        constructor(config) { super(config); this.size = config.size; this.w = this.h = config.size; }
    }
    // =========================================================================
    // GAME ORCHESTRATOR
    // =========================================================================
    class Game {
        constructor() {
            this.ui = new UIManager();
            this.input = new InputManager();
            this.ui.playBtn.onclick = () => this.reset();
            this.init();
        }
        
        init() {
            this.state = GameState.START;
            this.currentLevel = 0;
            this.gravity = 0;
            this.player = null;
            this.level = {};
            this.timer = 0;
            this.lastTime = 0;
            this.accumulator = 0;
        }

        loadLevel(levelIndex) {
            const levelData = LEVELS[levelIndex];
            if (!levelData) {
                this.endGame(true); // reached final portal
                return;
            }
            this.currentLevel = levelIndex;
            this.gravity = 0;
            this.timer = levelData.time;
            this.player = new Player({ ...levelData.playerStart, w: 24, h: 24 });
            this.level = {
                platforms: levelData.platforms.map(p => new Platform(p)),
                exit: new Exit(levelData.exit),
            };
        }

        reset() {
            this.init();
            this.loadLevel(0);
            this.state = GameState.PLAYING;
            this.ui.hideIntro();
            this.loop(performance.now());
        }

        togglePause() {
            if (this.state === GameState.PLAYING) {
                this.state = GameState.PAUSED;
                this.ui.showIntro("PAUSED");
            } else if (this.state === GameState.PAUSED) {
                this.state = GameState.PLAYING;
                this.ui.hideIntro();
                this.loop(performance.now());
            }
        }

        endGame(isWin) {
            this.state = GameState.END;
            if (isWin) {
                this.ui.showVictory();
            } else {
                this.ui.showIntro("OUT OF TIME\nPress 'Begin' to restart.");
            }
        }

        rotateWorld() {
            const center = { x: canvas.width / 2, y: canvas.height / 2 };
            const rotatePoint = (p) => {
                const dx = p.x - center.x;
                const dy = p.y - center.y;
                return { x: center.x - dy, y: center.y + dx };
            };

            this.gravity = (this.gravity + 1) & 3;
            
            [this.player, this.level.exit, ...this.level.platforms].forEach((e) => {
                const centerPos = e.center;
                const newCenter = rotatePoint(centerPos);
                if ('d' in e) {
                    e.d = (e.d + 3) & 3; // rotate platform orientation with gravity
                }
                [e.w, e.h] = [e.h, e.w];
                e.x = newCenter.x - e.w / 2;
                e.y = newCenter.y - e.h / 2;
            });

            [this.player.vx, this.player.vy] = [-this.player.vy, this.player.vx];
        }

        update(dt) {
            if (this.state !== GameState.PLAYING) return;

            // countdown timer
            this.timer -= dt;
            if (this.timer <= 0) {
                this.timer = 0;
                this.endGame(false);
                return;
            }

            // derive movement vectors based on current gravity
            const p = this.player;
            const gravVec = CONFIG.GRAVITY_DIRS[this.gravity];
            const moveVec = CONFIG.GRAVITY_DIRS[(this.gravity + 1) & 3];
            
            if (this.input.keys.left) { p.vx -= moveVec[0] * CONFIG.PHYSICS.playerAccel; p.vy -= moveVec[1] * CONFIG.PHYSICS.playerAccel; }
            if (this.input.keys.right) { p.vx += moveVec[0] * CONFIG.PHYSICS.playerAccel; p.vy += moveVec[1] * CONFIG.PHYSICS.playerAccel; }
            
            p.vx += gravVec[0] * CONFIG.PHYSICS.gravity;
            p.vy += gravVec[1] * CONFIG.PHYSICS.gravity;
            
            if (this.input.keys.jump && p.onGround) {
                this.input.keys.jump = false;
                p.vx -= gravVec[0] * CONFIG.PHYSICS.jumpImpulse;
                p.vy -= gravVec[1] * CONFIG.PHYSICS.jumpImpulse;
                this.rotateWorld();
            }

            p.vx *= CONFIG.PHYSICS.friction;
            p.vy *= CONFIG.PHYSICS.friction;
            p.x += p.vx * dt;
            p.y += p.vy * dt;

            // evaluate collisions against gravity-aligned platforms
            p.onGround = false;
            this.level.platforms.forEach(plat => {
                if (plat.d !== this.gravity || p.x + p.w < plat.x || p.x > plat.x + plat.w || p.y + p.h < plat.y || p.y > plat.y + plat.h) return;
                
                p.onGround = true;
                const prevX = p.x - p.vx * dt, prevY = p.y - p.vy * dt;
                
                if (gravVec[1] === 1 && prevY + p.h <= plat.y) { p.y = plat.y - p.h; p.vy = 0; }
                if (gravVec[1] === -1 && prevY >= plat.y + plat.h) { p.y = plat.y + plat.h; p.vy = 0; }
                if (gravVec[0] === 1 && prevX + p.w <= plat.x) { p.x = plat.x - p.w; p.vx = 0; }
                if (gravVec[0] === -1 && prevX >= plat.x + plat.w) { p.x = plat.x + plat.w; p.vx = 0; }
            });

            // check overlap with exit
            if (Math.hypot(p.center.x - this.level.exit.center.x, p.center.y - this.level.exit.center.y) < p.w / 2 + this.level.exit.size / 2) {
                this.loadLevel(this.currentLevel + 1);
            }
        }
        
        render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.level.platforms.forEach(p => {
                ctx.fillStyle = CONFIG.COLORS[p.d];
                ctx.globalAlpha = (p.d === this.gravity) ? 1 : 0.22;
                ctx.fillRect(p.x, p.y, p.w, p.h);
            });
            ctx.globalAlpha = 1;
            ctx.fillStyle = "#00fff0";
            ctx.fillRect(this.level.exit.x, this.level.exit.y, this.level.exit.size, this.level.exit.size);

            ctx.save();
            ctx.translate(this.player.center.x, this.player.center.y);
            ctx.rotate(this.gravity * Math.PI / 2);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(-this.player.w / 2, -this.player.h / 2, this.player.w, this.player.h);
            ctx.restore();
        }

        loop(currentTime) {
            if (this.state === GameState.END) return;
            if (!this.lastTime) this.lastTime = currentTime;
            const deltaTime = (currentTime - this.lastTime) / 1000;
            this.lastTime = currentTime;
            this.accumulator += deltaTime;

            while (this.accumulator >= CONFIG.TIMING.STEP) {
                if (this.state === GameState.PLAYING) this.update(CONFIG.TIMING.STEP);
                this.accumulator -= CONFIG.TIMING.STEP;
            }
            this.render();
            if(this.state !== GameState.PAUSED) this.ui.update(this);
            
            requestAnimationFrame(this.loop.bind(this));
        }
    }
    // =========================================================================
    // BOOTSTRAP
    // =========================================================================
    const game = new Game();
    global.RealityShiftRunner = game;
    
})(typeof globalThis !== "undefined" ? globalThis : window);
    </script>
</body>
</html>
